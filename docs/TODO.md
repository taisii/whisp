# TODO

## 1. 録音サウンド改善

### 背景
現状、録音終了時のみ音（880Hz正弦波、120ms）が鳴る仕様。録音開始時にも音を鳴らし、ユーザーに録音開始を明確にフィードバックする。また、終了音もシステムサウンドに統一する。

### 仕様
- **開始音・終了音**: 両方ともmacOSシステムサウンド「Tink」を使用
  - ファイルパス: `/System/Library/Sounds/Tink.aiff`
  - `rodio`クレートで再生
- **実装箇所**:
  - 開始: `lib.rs`の`start_recording()`内、録音開始直後
  - 終了: `lib.rs`の`stop_recording()`内、現行の`play_completion_sound()`を置き換え

### 実装タスク
- [ ] `sound.rs`の`play_completion_sound()`をTink再生に変更
- [ ] `sound.rs`に`play_start_sound()`関数を追加（Tink再生）
- [ ] `lib.rs`の`start_recording()`で`play_start_sound()`を呼び出し

---

## 2. ダッシュボード/設定画面の整理

### 背景
現在の設定画面はデバッグ用パネルが大きく占有しており、通常利用時には冗長。UIを整理し、shadcn/uiを導入してモダンなUIに刷新する。

### 仕様
- **UI基盤**: shadcn/ui を新規導入
- **統合プレイグラウンド**: 削除
- **デバッグパネル**: Accordion形式に変更
  - 各セクション（パイプライン状態、ログ、最新出力）を個別のAccordionItemとして配置
  - 複数セクションを同時に開ける（type="multiple"）
  - デフォルトは全て閉じた状態

### 実装タスク
- [ ] shadcn/ui をプロジェクトに導入（`bunx shadcn@latest init`）
- [ ] 必要なコンポーネントを追加（Card, Accordion, Input, Select, Switch等）
- [ ] `Settings.tsx`をshadcnコンポーネントでリファクタリング
- [ ] 統合プレイグラウンドセクションを削除
- [ ] デバッグパネルをAccordion形式に変更

---

## 3. 画面コンテキスト認識

### 背景
アクティブなアプリケーションを検出し、出力フォーマットを自動調整する。コードエディタではコード形式、メールアプリでは自然な文章など、コンテキストに応じた出力を実現。

### 参考
- [Aqua Voice](https://aquavoice.com): アクセシビリティAPIでアクティブアプリを検出、450ms以内のレスポンス

### 仕様

#### 取得情報
- **アクティブアプリ名**: `NSWorkspace`または`AXUIElement`経由で取得
- **選択テキスト**: アクセシビリティAPI（`AXUIElement`の`AXSelectedText`属性）で取得

#### プリセットルール
| カテゴリ | 対象アプリ | 出力フォーマット |
|---------|-----------|-----------------|
| コードエディタ | VSCode, Cursor, Xcode, Terminal | コード形式（技術用語優先、簡潔） |
| Claude Code | Claude Code | コード形式（技術用語優先） |
| 対話型ターミナル | Codex系ターミナル | コード形式 |
| デフォルト | その他 | 現行の標準フォーマット |

#### カスタムルール
- ユーザーがアプリ別ルールを追加可能
- UIはリスト形式（アプリ名 + プロンプト指示のペア）
- 設定は`config.toml`に保存

#### 適用方法
- コンテキスト情報（アプリ名、選択テキスト）は後処理プロンプトに自動付与
- ユーザーがテンプレート変数を意識する必要はない

### 実装タスク
- [ ] `context.rs`を新規作成（アクティブアプリ・選択テキスト取得）
- [ ] `Config`構造体に`context_rules: Vec<ContextRule>`を追加
- [ ] `post_processor.rs`でコンテキスト情報をプロンプトに付与
- [ ] 設定画面にコンテキストルール編集UIを追加

---

## 4. カスタムプロンプト設定

### 背景
後処理AIへのプロンプトをユーザーがカスタマイズ可能にする。出力スタイル（敬語/カジュアル、簡潔/詳細など）の調整を実現。

### 参考
- [Superwhisper Custom Mode](https://superwhisper.com/docs/modes/custom): プロンプト全体を自由編集、例文追加でAI精度向上

### 仕様

#### 自由度
- プロンプト全体を完全にカスタマイズ可能
- 複数行テキストエリアで編集

#### デフォルトテンプレート
現行プロンプトをデフォルト値として提供:
```
以下の音声認識結果を修正してください。修正後のテキストのみを出力してください。

修正ルール:
1. フィラー（えーと、あのー、えー、なんか、こう、まあ、ちょっと）を除去
2. 技術用語の誤認識を修正（例: "リアクト"→"React", "ユーズステート"→"useState"）
3. 句読点を適切に追加
4. 出力は{言語}にしてください

入力: {STT結果}
```

#### コンテキスト情報の付与
- システムがプロンプトに自動的にコンテキスト情報を付与
- アプリ名、選択テキストが自動的に追加される
- ユーザーはコンテキスト変数を意識する必要なし

### 実装タスク
- [ ] `Config`構造体に`custom_prompt: Option<String>`を追加
- [ ] `post_processor.rs`でカスタムプロンプト対応
- [ ] 設定画面にプロンプト編集UIを追加（複数行テキストエリア）
- [ ] デフォルトに戻すボタンを実装

---

## 5. 長押し録音（Push-to-Talk）機能

### 背景
現状はショートカットを押すたびに録音開始/停止をトグルする方式。長押ししている間だけ録音し、離すと自動停止するPush-to-Talk方式を追加することで、より直感的な操作を可能にする。

### 仕様
- **動作モード**: 設定で選択可能
  - **トグルモード（現行）**: 押すたびに録音開始/停止を切り替え
  - **長押しモード（新規）**: 押している間だけ録音、離すと停止
- **実装方式**: グローバルショートカットのKeyDown/KeyUpイベントを検出
- **UI**: 設定画面で動作モードを選択するトグル/セレクト

### 技術的考慮
- Tauriの`global_shortcut`はKeyDownのみ検出のため、別のアプローチが必要
- macOSでは`CGEventTap`または`NSEvent.addGlobalMonitorForEvents`でKeyUpを検出
- `rdev`クレートの利用を検討

### 実装タスク
- [ ] KeyUp検出の実装方法を調査・決定
- [ ] `shortcut.rs`または新規モジュールでKeyDown/KeyUp検出を実装
- [ ] `Config`に`recording_mode: RecordingMode`（Toggle/PushToTalk）を追加
- [ ] `lib.rs`で録音モードに応じた動作分岐
- [ ] 設定画面に録音モード選択UIを追加

---

## 6. ショートカットキーキャプチャ方式への変更

### 背景
現状、ショートカットはテキスト入力（例: "Cmd+J"）で設定する方式。ユーザーが正確なフォーマットを知る必要があり、入力ミスが起きやすい。実際にキーを押して認識させるキーキャプチャ方式に変更し、UXを改善する。

### 仕様
- **設定方法**: 「ショートカットを変更」ボタンをクリック → キャプチャモードに入る → ユーザーがキーコンビネーションを押す → 認識して表示・保存
- **UI表示**: 現在のショートカットをバッジ/ボタン形式で表示（例: `⌘ J`）
- **キャプチャ中UI**: 「キーを押してください...」のような案内を表示
- **キャンセル**: Escキーでキャプチャをキャンセル
- **バリデーション**: 修飾キー（Cmd/Ctrl/Alt/Shift）+ 通常キーの組み合わせを必須とする

### 実装タスク
- [ ] フロントエンドでキーキャプチャUIを実装（`keydown`イベント）
- [ ] 押されたキーを内部フォーマット（例: "Cmd+J"）に変換するロジック
- [ ] 表示用フォーマット（例: `⌘ J`）への変換
- [ ] 設定画面のショートカット入力をキーキャプチャ方式に変更
- [ ] バックエンドのショートカット登録ロジックは現行維持（内部フォーマットは同じ）

---

## 7. LLMモデル選択機能

### 背景
現状、後処理LLMはGemini（gemini-2.5-flash-lite）に固定されている。ユーザーがLLMプロバイダーやモデルを選択できるようにし、柔軟性を向上させる。

### 仕様

#### 対応プロバイダー・モデル
| プロバイダー | モデル | 備考 |
|-------------|--------|------|
| Google Gemini | gemini-2.5-flash-lite | 現行デフォルト、無料枠あり |
| OpenAI | gpt-4o-mini | 低コスト・高品質 |

#### UI
- **モデル選択**: フラットなドロップダウンリスト
  - 選択肢: `Gemini 2.5 Flash-Lite`, `GPT-4o-mini`
- **APIキー管理**: プロバイダーごとに個別入力欄
  - Gemini APIキー（既存）
  - OpenAI APIキー（新規追加）
- **デフォルト**: `gemini-2.5-flash-lite`

#### 設定構造
```toml
[api_keys]
deepgram = "..."
gemini = "..."
openai = "..."  # 新規追加

llm_model = "gemini-2.5-flash-lite"  # または "gpt-4o-mini"
```

### 実装タスク
- [ ] `Config`構造体に`api_keys.openai`と`llm_model`フィールドを追加
- [ ] `post_processor.rs`をリファクタリングしてプロバイダー抽象化
- [ ] OpenAI API呼び出しモジュールを実装
- [ ] 設定画面にモデル選択ドロップダウンを追加
- [ ] 設定画面にOpenAI APIキー入力欄を追加
- [ ] 選択されたモデルに応じてAPIキーのバリデーション

---

## 実装優先度

1. **録音サウンド改善** - 最小変更、すぐ実装可能
2. **ダッシュボード/設定画面の整理** - shadcn導入が他機能のUI基盤になる
3. **ショートカットキーキャプチャ** - 設定画面リファクタリングと同時に実装
4. **LLMモデル選択機能** - 設定画面と同時に実装可能
5. **長押し録音（Push-to-Talk）** - キー検出の調査が必要
6. **カスタムプロンプト設定** - 単独で実装可能
7. **画面コンテキスト認識** - 最も複雑、アクセシビリティ権限が必要
